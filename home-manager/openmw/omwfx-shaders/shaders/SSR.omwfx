fragment main {

    omw_In vec2 omw_TexCoord;
	
	const float sky = 1e6;
    #define N 16 // Samples: 48, 32, 16, 10, 6. More means precision and performance hit.

    vec2 rcpres = 1.0 / omw.resolution;

    vec2 t = 2.0 * tan(radians(omw.fov * 0.5)) * vec2(1.0, rcpres.x / rcpres.y);

    vec2 fromView(vec3 view)
    {
        return vec2(view.xy / t / view.z + 0.5);
    }

    vec3 toView(vec2 tex)
    {
        float depth = min(omw_GetLinearDepth(tex), sky);
        vec2 xy = (tex - 0.5) * depth * t;
        return vec3(xy, depth);
    }
	
	vec3 toWorld(vec2 tex)
    {
        vec3 v = vec3(omw.viewMatrix[0][2], omw.viewMatrix[1][2], omw.viewMatrix[2][2]);
        v += vec3(1/omw.projectionMatrix[0][0] * (2*(1 - tex.x)-1)) * vec3(omw.viewMatrix[0][0], omw.viewMatrix[1][0], omw.viewMatrix[2][0]);
        v += vec3(-1/omw.projectionMatrix[1][1] * (2*tex.y-1)) * vec3(omw.viewMatrix[0][1], omw.viewMatrix[1][1], omw.viewMatrix[2][1]);
        return v;
    }
	
    vec3 wpos_at(vec2 uv) {
        float depth = omw_GetDepth(uv);
        vec4 clip_space = vec4(uv * 2.0 - 1.0, 1 - depth, 1.0);
        if (depth == 1) {
            vec4 world_space = omw.invViewMatrix * ((omw.invProjectionMatrix * clip_space) * vec4(1, 1, 1, 0));
            return normalize(world_space.xyz) * sky;
        } else {
            vec4 world_space = omw.invViewMatrix * (omw.invProjectionMatrix * clip_space);
            return world_space.xyz / world_space.w;
        }
    }
	
	
	vec3 vpos_at(vec2 uv) {
        float depth = omw_GetDepth(uv);
		depth = -depth/omw.far;
        vec4 clip_space = vec4(uv * 2.0 - 1.0, depth, 1.0);
        vec4 world_space = (omw.invProjectionMatrix * clip_space);
        return world_space.xyz / world_space.w;
    }
	
	
	vec3 PositionFromDepth(float depth) {
		float z = depth * 2.0 - 1.0;

		vec4 clipSpacePosition = vec4(omw_TexCoord * 2.0 - 1.0, z, 1.0);
		
		vec4 viewSpacePosition = omw.invProjectionMatrix * clipSpacePosition;

		// Perspective division
		viewSpacePosition /= viewSpacePosition.w;

		return viewSpacePosition.xyz;
	}


	/*
	const float rayStep = 0.1;
	const float minRayStep = 0.1;
	const float maxSteps = 50;
	const float searchDist = 5;
	const float searchDistInv = 0.2;
	const int numBinarySearchSteps = 5;
	const float maxDDepth = 1.0;
	const float maxDDepthInv = 1.0;
	*/	
		
	// Consts should help improve performance
	const float rayStep = 0.01;
	const float minRayStep = 0.9;
	const float maxSteps = 50;
	const float searchDist = 5;
	const float searchDistInv = 0.2;
	const int numBinarySearchSteps = 5;
	const float maxDDepth = 1.0;
	const float maxDDepthInv = 1.0;


	const float reflectionSpecularFalloffExponent = 3.0;




	vec3 BinarySearch(inout vec3 dir, inout vec3 hitCoord, inout float dDepth)
	{
		float depth;
		vec4 projectedCoord;


		for(int i = 0; i < numBinarySearchSteps; i++)
		{
			projectedCoord = omw.projectionMatrix * vec4(hitCoord, 1.0);
			projectedCoord.xy /= projectedCoord.w;
			projectedCoord.xy = projectedCoord.xy * vec2(0.5) + 0.5;


			depth = vpos_at(projectedCoord.xy).z;

			dDepth = hitCoord.z - depth;
			
			if(dDepth > 0.0)
				hitCoord += dir;
			
			dir *= 0.5;
			hitCoord -= dir;
		}


		projectedCoord = omw.projectionMatrix * vec4(hitCoord, 1.0); 
		projectedCoord.xy /= projectedCoord.w;
		projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;


		return vec3(projectedCoord.xy, depth);
	}


	vec4 RayCast(in vec3 dir, inout vec3 hitCoord, out float dDepth, inout float reflection)
	{
		dir *= rayStep;
		
		


		float depth;
		int steps;
		vec4 projectedCoord;
		

		for(int i = 0; i < maxSteps; i++)
		{
			if(i > 38)
				dir*= 3;
				
				
			hitCoord += dir;


			projectedCoord = omw.projectionMatrix * vec4(hitCoord, 1.0);
			projectedCoord.xy /= projectedCoord.w;
			projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;
			

			depth = vpos_at(projectedCoord.xy).z;


			
			
			dDepth = hitCoord.z - depth;


			
			
			if(projectedCoord.z < depth * 0.00025) {
				reflection = 1.0;
			} else {
				reflection = 0.0;
			}
			
			
			
			if(dDepth < 0.0)
				return vec4(BinarySearch(dir, hitCoord, dDepth), 1.0);
		}


		return vec4(0);
	}

	vec3 fresnelSchlick(float cosTheta, vec3 F0)
	{
		return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
	}
	
	vec3 fresnelSchlickUnderwater(float cosTheta, vec3 F0)
	{
		float n1 = 1.000293;   // air
		float n2 = 1.001000; // water
		float eta = (n2 / n1);
		float k = eta * eta * (1.0 - cosTheta * cosTheta);
	
		if (k > 1.0) {     // Total internal Reflection
			return vec3(1.0);
		}
		cosTheta = sqrt(1.0 - k);
		
		return mix(F0, vec3(1.0), pow(1.0 - cosTheta, 5.0));
	}
	
	
	float fresnel_dielectric(vec3 Incoming, vec3 Normal, float eta)
  {
    float c = abs(dot(Incoming, Normal));
    float g = eta * eta - 1.0 + c * c;
    float result;

    if(g > 0.0) {
        g = sqrt(g);
        float A =(g - c)/(g + c);
        float B =(c *(g + c)- 1.0)/(c *(g - c)+ 1.0);
        result = 0.5 * A * A *(1.0 + B * B);
    }
    else
        result = 1.0;  /* TIR (no refracted component) */

    return result;
  }
	
	
	void main()
	{

		vec4 orgcol = omw_GetLastShader(omw_TexCoord);
		vec3 w = wpos_at(omw_TexCoord);
		vec3 wpos = toView(omw_TexCoord);
		
		float depth = omw_GetDepth(omw_TexCoord);
		float wdepth = omw_GetLinearDepth(omw_TexCoord);
		
		float raised = omw.waterHeight - 4 - (omw.far * 0.00059) * clamp(wdepth * 0.00005, 0,1);
		
		float wmask = float((w.z + raised)<0.0);
		
		if(omw.eyePos.z < (omw.waterHeight))
			wmask = w.z - raised - 3;
			
		wmask *= float(omw.isWaterEnabled);
		
		if(depth == 1)
			wmask = 0;
		
		
		vec3 pixel_normal = vec3(0.0);
		vec3 normalpass = vec3(0.0);
		
		
		//depth = omw_GetLinearDepth(omw_TexCoord);
		 
		#if OMW_NORMALS
		if(depth != 1)	
		normalpass = omw_GetNormals(omw_TexCoord);
		#endif
		pixel_normal = normalpass.xyz;
		float x = pixel_normal.x;
		float y = pixel_normal.y;
		pixel_normal.z = sqrt( 1. - clamp(x*x + y*y, 0.0,1.0));
		
		
	
		//pixel_normal = normalize(vec3(0.0,0.0,1.0));
		//pixel_normal = 2 * pixel_normal - 1;
		vec3 wnorm = pixel_normal;
		
		vec4 col = omw_GetLastShader(omw_TexCoord);
		
		vec3 wnormpuddle = normalize(vec3(wnorm.xy, wnorm.z * (1.0 - col.a) * 50));
		
		wnorm = normalize(vec3(wnorm.xy, wnorm.z * 3));
		
		
		
		wnorm = mix(wnorm, wnormpuddle, clamp(100 * (1-col.a), 0,1));
		
		
		
		mat4 viewNoTranslation = omw.viewMatrix; 
		viewNoTranslation[3] = vec4(0.0, 0.0, 0.0, 1.0);
		vec4 vnorm = viewNoTranslation * vec4(wnorm, 1.0);
		
		float specular = 0.0;
		
		
		#ifdef SPECULARREF 
		specular = max(col.a, specular);
		#else
		specular = max(1-orgcol.a, wmask);
		#endif
		if(specular < 0.1)
		{
			omw_FragColor = omw_GetLastShader(omw_TexCoord.xy);
			return;
		}
		
		vec3 vp  = vpos_at(omw_TexCoord);
		
				
		vec3 viewNormal = vnorm.xyz;
		vec3 viewPos = vp.xyz;
 	
				
		vec3 F0 = vec3(0.02); 
		//F0 = mix(F0, albedo, Metallic);
		//vec3 Fresnel = fresnelSchlick(max(dot(normalize(viewNormal), normalize(-viewPos)), 0.0), F0); 
		
		
		
		
		//if(omw.eyePos.z < (omw.waterHeight))
			//Fresnel = fresnelSchlickUnderwater(max(dot(normalize(-viewNormal), normalize(-viewPos)), 0.0), F0);
		
			
		// fresnel
		float ior = (omw.eyePos.z>0.0)?(1.333/1.0):(1.0/1.1); // air to water; water to air
		float fresnel = clamp(fresnel_dielectric(normalize(-viewPos), normalize(viewNormal), ior), 0.0, 1.0);
		
		
		
		
		// Reflection vector
		vec3 reflected = normalize(reflect(normalize(viewPos), normalize(viewNormal)));
	 
		// Ray cast
		vec3 hitPos = viewPos;
		
		float dDepth;
		float reflection;
		
		
		vec4 coords = RayCast(reflected * max(minRayStep, -viewPos.z), hitPos, dDepth, reflection);
		
		
		//coords.y = 1.0 - coords.y;
		
		
		vec2 dCoords = smoothstep(0.35, 0.88, vec2(0,0) +  abs(vec2(0.5, 0.5) - coords.xy));


		float screenEdgefactor =  clamp(2.5 * clamp(1.0 - (dCoords.x + coords.y), 0.0, 1.0), 0.0, 1.0);
		
		float underwaterFactor = coords.y + coords.y;
			
		float reflectionMultiplier = underwaterFactor * screenEdgefactor * -reflected.z;
		
		reflectionMultiplier *= fresnel; // * clamp(reflectionMultiplier, 0.0, 0.9);
		
						
		//reflectionMultiplier += screenEdgefactor * fresnel * specular * 0.1;
		
		//reflectionMultiplier = pow(Fresnel.x,109); 
			
		vec3 SSR = omw_GetLastShader(coords.xy).rgb;
		SSR = mix(col.rgb, SSR , clamp(1 * reflectionMultiplier, 0.0,1.0));
		float eraser = mix(0.0, 0.2, reflectionMultiplier);
		
		vec3 resultSSR = SSR;
		if(wmask * reflection > 0.5)
			resultSSR = orgcol.rgb;
			
		//if( (1-wmask) * (1-orgcol.a) > 0.0 );
			//resultSSR = SSR;
		
		//omw_FragColor = vec4(0.0);
		
		
		omw_FragColor = vec4(vec3(resultSSR), 1.0);
	}
}

technique {
    passes = main;
    description = "VV";
    author = "OpenMW";
    version = "1.0";
	pass_normals = true;
}
