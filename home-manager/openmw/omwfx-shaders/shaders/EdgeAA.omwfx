sampler_2d WeightMapSampler {
    source = "shaders/textures/mlaa_area.dds";
    mag_filter = linear;
    min_filter = linear;
    wrap_s = clamp_to_edge;
    wrap_t = clamp_to_edge;
}

shared {

    #define	depthThreshold	100.55
    #define MAX_SEARCH_STEPS	4
    #define MAX_DISTANCE		32
    #define MAP_SIZE		256

    const mat3 YUVs_RGB  = mat3(
                0.29900, 0.58700, 0.11400,
                -0.14740, -0.28950, 0.43690,
                0.61500, -0.51500, -0.10000);

    float GetIntensity( const vec3 rgb )
    {
    //  return dot( rgb, vec3( 0.333, 0.334, 0.333 ) );
        return dot( YUVs_RGB[0], rgb );
    }

    float LinearDepth(in vec2 tex)
    {
        float d = omw_GetDepth(tex);
#if OMW_REVERSE_Z
        float ndc = d;
#else
        float ndc = d * 2.0 - 1.0;
#endif
        return omw.near * omw.far / (omw.far + ndc * (omw.near - omw.far));
    }
}

fragment RenderMixEdgeDetectionPS {
    omw_In vec2 omw_TexCoord;

    void main()
    {
        // detect depth Edge
        float	dCenter = LinearDepth(omw_TexCoord);
        float	dTop    = LinearDepth(omw_TexCoord - vec2(0.0, omw.rcpResolution.y));
        float	dBottom = LinearDepth(omw_TexCoord + vec2(0.0, omw.rcpResolution.y));
        float	dLeft   = LinearDepth(omw_TexCoord - vec2(omw.rcpResolution.x, 0.0));
        float	dRight  = LinearDepth(omw_TexCoord + vec2(omw.rcpResolution.x, 0.0));

        vec4	delta = abs( vec4(dCenter) - vec4(dLeft, dTop, dRight, dBottom) );
        vec4	edge = step( vec4(depthThreshold), delta );
    
        omw_FragColor = clamp(edge, 0.0, 1.0);
    }
}


fragment RenderBlendWeightPS {
    omw_In vec2 omw_TexCoord;
    // #undef TEST_MODE
    float SearchLeftRight(vec2 UVCoord, vec2 delta) {
        float	edge = 0.0;
        int	step = 0, intr = 0;
    
        for(step = 0; step < MAX_SEARCH_STEPS; step++) {
            edge = omw_Texture2D(omw_SamplerLastPass, UVCoord).g;
    
            intr = step;
            if (edge < 0.9)
                step = MAX_SEARCH_STEPS;//break;
    
            UVCoord += delta;
        }
    
        return min(2.0 * intr + 2.0 * edge, 2.0 * MAX_SEARCH_STEPS);
    }
    
    float SearchTopBottom(vec2 UVCoord, vec2 delta) {
        float	edge = 0.0;
        int	step, intr = 0;
    
        for (step = 0; step < MAX_SEARCH_STEPS; step++) {
            edge = omw_Texture2D(omw_SamplerLastPass, UVCoord).r;
    
            intr = step;
            if (edge < 0.9)
                step = MAX_SEARCH_STEPS;//break;
    
            UVCoord += delta;
        }
    
        return min(2.0 * intr + 2.0 * edge, 2.0 * MAX_SEARCH_STEPS);
    }
    
    // functions
    vec2 GetWeight(vec2 distance, vec2 shape) {
        // * By dividing by MAP_SIZE - 1.0 below we are implicitely offsetting to
        //   always fall inside of a pixel
        // * Rounding prevents bilinear access precision problems
        float  areaSize = MAX_DISTANCE * 5.0;
        vec2 pixCoord = MAX_DISTANCE * round(4.0 * shape) + distance;
        vec2 texCoord = pixCoord / (areaSize - 1.0);
    
        return omw_Texture2D(WeightMapSampler, texCoord).rg;
    }

    void main()
    {
        vec4	edge = texelFetch(omw_SamplerLastPass, ivec2(omw_TexCoord * omw.resolution), 0);

        if((edge.g + edge.r) <= 0.0)
        {
            omw_FragColor = omw_GetLastShader(omw_TexCoord);
            return;
        }

        vec4	weight = vec4(0.0);
    
        // Edge at north
        if (edge.g) {
            // Search distances to the left and to the right
    
            /* TODO: 2x SearchLeftRight can be collapsed into one loop */
            vec2	start = vec2(1.5, 0.0) * omw.rcpResolution;
            vec2	delta = vec2(2.0, 0.0) * omw.rcpResolution;
            vec2	dist = vec2(
                SearchLeftRight(omw_TexCoord - start, -delta),
                SearchLeftRight(omw_TexCoord + start,  delta));
    
            vec4	UVCoord = vec4(omw_TexCoord.xy, omw_TexCoord.xy) + vec4(-dist.x, -0.25, dist.y + 1.0, -0.25) * omw.rcpResolution.xyxy;
            float	shape1 = omw_Texture2D(omw_SamplerLastPass, UVCoord.xy).r;
            float	shape2 = omw_Texture2D(omw_SamplerLastPass, UVCoord.zw).r;
    
            weight.rg = GetWeight(dist, vec2(shape1, shape2));
        }
    
        // Edge at west
        if (edge.r) {
            // Search dists to the top and to the bottom
    
            /* TODO: 2x SearchTopBottomcan be collapsed into one loop */
            vec2	start = vec2(0.0, 1.5) * omw.rcpResolution;
            vec2	delta = vec2(0.0, 2.0) * omw.rcpResolution;
            vec2	dist = vec2(
                SearchTopBottom(omw_TexCoord - start, -delta),
                SearchTopBottom(omw_TexCoord + start,  delta));
    
            vec4	UVCoord = vec4(omw_TexCoord.xy, omw_TexCoord.xy) + vec4(-0.25, -dist.x, -0.25, dist.y + 1.0) * omw.rcpResolution.xyxy;
            float	shape1 = omw_Texture2D(omw_SamplerLastPass, UVCoord.xy).g;
            float	shape2 = omw_Texture2D(omw_SamplerLastPass, UVCoord.zw).g;
    
            weight.ba = GetWeight(dist, vec2(shape1, shape2));
        }
    
    #ifdef	TEST_MODE
        // test mode.
        weight = clamp(vec4(edge.r + edge.b, edge.g + edge.a, 0.0, 0.0), 0.0, 1.0);
    #endif
         omw_FragColor = weight;
    }
}

fragment RenderBlendingPS {
    omw_In vec2 omw_TexCoord;

    void main()
    {
        // Fetch the blending weights for current pixel
        vec4	top_left = texelFetch(omw_SamplerLastPass, ivec2(omw_TexCoord * omw.resolution), 0);
        float	bottom   = texelFetch(omw_SamplerLastPass, ivec2((omw_TexCoord + vec2(0, omw.rcpResolution.y)) * omw.resolution), 0).g;
        float	right    = texelFetch(omw_SamplerLastPass, ivec2((omw_TexCoord + vec2(omw.rcpResolution.x, 0)) * omw.resolution), 0).a;
    
        vec4 a = vec4(top_left.r, bottom, top_left.b, right);
    
        // Up to 4 lines can be crossing a pixel (one in each edge). So, we perform
        // a weighted average, where the weight of each line is 'a' cubed, which
        // favors blending and works well in practice.
    //	vec4	weight = a * a * a;
    
        // I use original, look like beter in Oblivion
        vec4	weight = a;
        float	sum = dot(weight, vec4(1.0));
    
        /* read the point-samples individually, we need the values for multiple things */
        vec3 ccenter = texelFetch(omw_SamplerLastShader, ivec2(omw_TexCoord * omw.resolution), 0).rgb;
        vec3 cleft   = texelFetch(omw_SamplerLastShader, ivec2((omw_TexCoord + vec2(-omw.rcpResolution.x, 0.0)) * omw.resolution), 0).rgb;
        vec3 cright  = texelFetch(omw_SamplerLastShader, ivec2((omw_TexCoord + vec2( omw.rcpResolution.x, 0.0)) * omw.resolution), 0).rgb;
        vec3 ctop    = texelFetch(omw_SamplerLastShader, ivec2((omw_TexCoord + vec2(0.0, -omw.rcpResolution.y)) * omw.resolution), 0).rgb;
        vec3 cbottom = texelFetch(omw_SamplerLastShader, ivec2((omw_TexCoord + vec2(0.0,  omw.rcpResolution.y)) * omw.resolution), 0).rgb;
    
        // Contrast detection
        vec3 edges = 4.0 * abs((cleft + cright + ctop + cbottom) - 4.0 * ccenter);
        float  edges_lum = GetIntensity(edges);
        vec3 mcenter = ccenter;
    
        /* we got the point-samples already, no need to fetch again */
        if (sum > 1e-5) {
            mcenter  = vec3(0.0);
    
    #if 1
            mcenter += mix(ccenter, ctop,    a.r) * weight.r;
            mcenter += mix(ccenter, cbottom, a.g) * weight.g;
            mcenter += mix(ccenter, cleft,   a.b) * weight.b;
            mcenter += mix(ccenter, cright,  a.a) * weight.a;
    #else
            vec4 UVCoord = vec4(omw_TexCoord.xy, omw_TexCoord.xy) + vec4(0.0, -a.r, 0.0, a.g) * vec4(omw.rcpResolution.xy, omw.rcpResolution.xy);
            mcenter += omw_GetLastShader(UVCoord.xy).rgb * weight.r;
            mcenter += omw_GetLastShader(UVCoord.zw).rgb * weight.g;
    
            UVCoord = vec4(omw_TexCoord.xy, omw_TexCoord.xy) + vec4(-a.b, 0.0, a.a, 0.0) * vec4(omw.rcpResolution.xy, omw.rcpResolution.xy);
            mcenter += omw_GetLastShader(UVCoord.xy).rgb * weight.b;
            mcenter += omw_GetLastShader(UVCoord.zw).rgb * weight.a;
    #endif
    
            // Normalize the resulting color
            mcenter /= sum;
        }
 
	    omw_FragColor = vec4(mcenter, edges_lum);
    }
}

fragment PostProcessPS {
    omw_In vec2 omw_TexCoord;

    #define TFU2_HIGH_PASS
    #define VECTORIZED_SEARCH
    
    #define LDc(o, dx, dy) o = omw_Texture2D(omw_SamplerLastPass, omw_TexCoord + vec2(dx, dy) * omw.rcpResolution.xy);
    #define LDl(o, dx, dy) o = omw_Texture2D(omw_SamplerLastPass, omw_TexCoord + vec2(dx, dy) * omw.rcpResolution.xy);

    const bool bAA = true;
    const bool bPreserveHf = false;

    void main()
    {
        const float lambda = 3.0;
        const float epsilon = 0.1;
    
        //
        // Short Edges
        //
    
        vec4 center, left_01, right_01, top_01, bottom_01;
    
        // sample 5x5 cross
        LDc( center,      0.0,   0.0 )
        LDc( left_01,  -1.5,   0.0 )
        LDc( right_01,  1.5,   0.0 )
        LDc( top_01,      0.0,-1.5 )
        LDc( bottom_01,   0.0, 1.5 )
    
        if ( !bAA )
        {
            omw_FragColor = center;
            return;
        }
    
        vec4 w_h = 2.0 * ( left_01 + right_01 );
        vec4 w_v = 2.0 * ( top_01 + bottom_01 );
    
        #ifdef TFU2_HIGH_PASS
    
            // Softer (5-pixel wide high-pass)
            vec4 edge_h = abs( w_h - 4.0 * center ) / 4.0;
            vec4 edge_v = abs( w_v - 4.0 * center ) / 4.0;
    
        #else
    
            // Sharper (3-pixel wide high-pass)
            vec4 left, right, top, bottom;
    
            LDc( left,  -1.0,  0.0 )
            LDc( right,  1.0,  0.0 )
            LDc( top,    0.0, -1.0 )
            LDc( bottom, 0.0,  1.0 )
    
            vec4 edge_h = abs( left + right - 2.0 * center ) / 2.0;
            vec4 edge_v = abs( top + bottom - 2.0 * center ) / 2.0;
    
        #endif
    
        vec4 blurred_h = ( w_h + 2.0 * center ) / 6.0;
        vec4 blurred_v = ( w_v + 2.0 * center ) / 6.0;
    
        float edge_h_lum = /*edge_h.w;		//*/GetIntensity( edge_h.xyz );
        float edge_v_lum = /*edge_v.w;		//*/GetIntensity( edge_v.xyz );
        float blurred_h_lum = /*blurred_h.w;	//*/GetIntensity( blurred_h.xyz );
        float blurred_v_lum = /*blurred_v.w;	//*/GetIntensity( blurred_v.xyz );
    
        float edge_mask_h = clamp( ( lambda * edge_h_lum - epsilon ) / blurred_v_lum , 0.0, 1.0);
        float edge_mask_v = clamp( ( lambda * edge_v_lum - epsilon ) / blurred_h_lum , 0.0, 1.0);
    
        vec4 clr = center;

        clr = mix( clr, blurred_h, edge_mask_v );
        clr = mix( clr, blurred_v, edge_mask_h * 0.5 ); // TFU2 uses 1.0 instead of 0.5f
        
        //
        // Long Edges
        //
    
        vec4 h0, h1, h2, h3, h4, h5, h6, h7;
        vec4 v0, v1, v2, v3, v4, v5, v6, v7;
    
        // sample 16x16 cross (sparse-sample on X360, incremental kernel update on SPUs)
        LDc( h0, 1.5, 0.0 ) LDc( h1, 3.5, 0.0 ) LDc( h2, 5.5, 0.0 ) LDc( h3, 7.5, 0.0 )
        LDc( h4, -1.5,0.0 ) LDc( h5, -3.5,0.0 ) LDc( h6, -5.5,0.0 ) LDc( h7, -7.5,0 )
        LDc( v0, 0.0, 1.5 ) LDc( v1, 0.0, 3.5 ) LDc( v2, 0.0, 5.5 ) LDc( v3, 0.0, 7.5 )
        LDc( v4, 0.0,-1.5 ) LDc( v5, 0.0,-3.5 ) LDc( v6, 0.0,-5.5 ) LDc( v7, 0.0,-7.5 )
    
        float long_edge_mask_h = ( h0.a + h1.a + h2.a + h3.a + h4.a + h5.a + h6.a + h7.a ) / 8.0;
        float long_edge_mask_v = ( v0.a + v1.a + v2.a + v3.a + v4.a + v5.a + v6.a + v7.a ) / 8.0;
    
        long_edge_mask_h = clamp( long_edge_mask_h * 2.0 - 1.0, 0.0, 1.0);
        long_edge_mask_v = clamp( long_edge_mask_v * 2.0 - 1.0, 0.0, 1.0);
    
    //  if ( long_edge_mask_h > 0 || long_edge_mask_v > 0 )	// faster but less resistant to noise (TFU2 X360)
        if ( abs( long_edge_mask_h - long_edge_mask_v ) > 0.2 )	// resistant to noise (TFU2 SPUs)
        {
            vec4 left, right, top, bottom;
    
            LDl( left,  -1.0,  0.0 )
            LDl( right,  1.0,  0.0 )
            LDl( top,    0.0, -1.0 )
            LDl( bottom, 0.0,  1.0 )
    
            vec4 long_blurred_h = ( h0 + h1 + h2 + h3 + h4 + h5 + h6 + h7 ) / 8.0;
            vec4 long_blurred_v = ( v0 + v1 + v2 + v3 + v4 + v5 + v6 + v7 ) / 8.0;
    
            float lb_h_lum   = /*long_blurred_h.w;	//*/GetIntensity( long_blurred_h.xyz );
            float lb_v_lum   = /*long_blurred_v.w;	//*/GetIntensity( long_blurred_v.xyz );
    
            float center_lum = /*center.w;		//*/GetIntensity( center.xyz );
            float left_lum   = /*left.w;			//*/GetIntensity( left.xyz );
            float right_lum  = /*right.w;			//*/GetIntensity( right.xyz );
            float top_lum    = /*top.w;			//*/GetIntensity( top.xyz );
            float bottom_lum = /*bottom.w;		//*/GetIntensity( bottom.xyz );
    
            vec4 clr_v = center;
            vec4 clr_h = center;
    
            #ifdef VECTORIZED_SEARCH
    
                // vectorized search (X360 GPU and SPU implementation friendly)
                float hx = clamp( 0 + ( lb_h_lum - top_lum    ) / ( center_lum - top_lum    ), 0.0, 1.0);
                float hy = clamp( 1 + ( lb_h_lum - center_lum ) / ( center_lum - bottom_lum ), 0.0, 1.0);
                float vx = clamp( 0 + ( lb_v_lum - left_lum   ) / ( center_lum - left_lum   ), 0.0, 1.0);
                float vy = clamp( 1 + ( lb_v_lum - center_lum ) / ( center_lum - right_lum  ), 0.0, 1.0);
    
                vec4 vhxy = vec4( vx, vy, hx, hy );
                vhxy = vhxy == vec4( 0, 0, 0, 0 ) ? vec4( 1, 1, 1, 1 ) : vhxy;
    
                clr_v = mix( left  , clr_v, vhxy.x );
                clr_v = mix( right , clr_v, vhxy.y );
                clr_h = mix( top   , clr_h, vhxy.z );
                clr_h = mix( bottom, clr_h, vhxy.w );
    
            #else
    
                // naive search
                float hx = clamp( ( lb_h_lum - top_lum    ) / ( center_lum - top_lum    ), 0.0, 1.0);
                float hy = clamp( ( lb_h_lum - center_lum ) / ( bottom_lum - center_lum ), 0.0, 1.0);
                float vx = clamp( ( lb_v_lum - left_lum   ) / ( center_lum - left_lum   ), 0.0, 1.0);
                float vy = clamp( ( lb_v_lum - center_lum ) / ( right_lum  - center_lum ), 0.0, 1.0);
    
                if ( hx == 0 ) hx = 1;
                if ( vx == 0 ) vx = 1;
    
                clr_v = mix( left, clr_v, vx );
                if ( vy < 1 ) clr_v = mix( clr_v, right, vy );
    
                clr_h = mix( top, clr_h, hx );
                if ( hy < 1 ) clr_h = mix( clr_h, bottom, hy );
    
            #endif
    
            clr = mix( clr, clr_v, long_edge_mask_v );
            clr = mix( clr, clr_h, long_edge_mask_h );
        }
    
        //
        // Preserve high frequencies (not used in TFU2)
        //
    
        if ( bPreserveHf )
        {
            vec4 r0, r1;
            vec4 r2, r3;
    
            LDc( r0, -1.5, -1.5 )
            LDc( r1,  1.5, -1.5 )
            LDc( r2, -1.5,  1.5 )
            LDc( r3,  1.5,  1.5 )
    
            // faster version
            //r0 = top_01;
            //r1 = bottom_01;
            //r2 = left_01;
            //r3 = right_01;
    
            vec4 r = ( 4.0 * ( r0 + r1 + r2 + r3 ) + center + top_01 + bottom_01 + left_01 + right_01 ) / 25.0;
            clr = mix( clr, center, clamp( r.a * 3.0 - 1.5, 0.0, 1.0) );
        }

        omw_FragColor = clr;
    }
}

fragment RenderMixEdgeDetectionPSPost {
    omw_In vec2 omw_TexCoord;

    void main()
    {
        // detect depth Edge
        float	dCenter = LinearDepth(omw_TexCoord);
        float	dTop    = LinearDepth(omw_TexCoord - vec2(0.0, omw.rcpResolution.y));
        float	dBottom = LinearDepth(omw_TexCoord + vec2(0.0, omw.rcpResolution.y));
        float	dLeft   = LinearDepth(omw_TexCoord - vec2(omw.rcpResolution.x, 0.0));
        float	dRight  = LinearDepth(omw_TexCoord + vec2(omw.rcpResolution.x, 0.0));
    
        vec4	delta = abs( vec4(dCenter) - vec4(dLeft, dTop, dRight, dBottom) );
        vec4	edge = step( vec4(depthThreshold), delta );

        vec4 orgi = texelFetch(omw_SamplerLastShader, ivec2(omw_TexCoord * omw.resolution), 0);
        vec4 res = texelFetch(omw_SamplerLastPass, ivec2(omw_TexCoord * omw.resolution), 0);

        edge = vec4(clamp((edge.x + edge.y + edge.z + edge.a) * 10.0, 0.0, 1.0));
        res = mix(orgi, res, edge);
        omw_FragColor = res;
    }
}

technique {
    passes = RenderMixEdgeDetectionPS, RenderBlendWeightPS, RenderBlendingPS, PostProcessPS, RenderMixEdgeDetectionPSPost;
    description = "Edge AA. Can be used in combination with FXAA and other forms of AA";
    author = "Vtastek, ported by Wazabear";
    version = "1.0";
    glsl_version = 330;
}
